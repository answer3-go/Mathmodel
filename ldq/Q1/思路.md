### **求解问题一的思路与数学公式**

我们的核心思路，就是模拟从 `t=0` 到导弹飞过目标区的整个过程。在这个过程中，我们像放电影一样，一帧一帧地（即一个时间步长一个时间步长地）去检查遮蔽是否发生。如果发生了，我们就把这一帧的时间累加起来，最后得到的总和就是答案。

这在数学上，本质是一个**分段函数的定积分**问题。

#### **1. 核心思路**

1. **确定积分区间**: 我们需要确定一个有意义的仿真时间范围。起点是 `t_start = 0`，终点 `t_end` 可以取导弹飞过真目标所在平面（即X坐标变为负数）的时刻。
2. **定义被积函数**: 我们需要定义一个随时间变化的“遮蔽状态函数” $V(t)$。
   * 当在时刻 $t$ **发生遮蔽**时，$V(t) = 1$。
   * 当在时刻 $t$ **未发生遮蔽**时，$V(t) = 0$。
3. **计算定积分**: 我们要求的总遮蔽时长 $T_{total}$，就是对这个状态函数 $V(t)$ 在整个仿真区间上的定积分：
   $$
   T_{total} = \int_{t_{start}}^{t_{end}} V(t) \,dt
   $$
4. **数值计算方法（离散化）**: 由于 $V(t)$ 是一个复杂的、不连续的函数，我们无法直接用解析方法求解积分。因此，我们采用**数值积分**的方法，将连续的时间轴离散化为一系列微小的时间步长 $\Delta t$。
   * 我们将时间轴切分为 $N$ 个点：$t_0, t_1, t_2, ..., t_N$，其中 $t_i = i \cdot \Delta t$。
   * 在每个时间点 $t_i$，我们去计算 $V(t_i)$ 的值（即判断在这一瞬间是否遮蔽）。
   * 总遮蔽时长就是所有被遮蔽的时间步长的总和：
     $$
     T_{total} \approx \sum_{i=0}^{N} V(t_i) \cdot \Delta t
     $$

#### **2. 求解步骤与核心数学公式**

**Step 1: 确定仿真的关键时间点**

* **投放时间**: $t_{drop} = 1.5$ s
* **引信延迟**: $\Delta t_{delay} = 3.6$ s
* **起爆时间**: $t_{detonate} = t_{drop} + \Delta t_{delay} = 1.5 + 3.6 = 5.1$ s
* **烟幕云失效时间**: $t_{expire} = t_{detonate} + 20 = 25.1$ s

**Step 2: 建立时空运动模型的核心公式**

令 $\vec{P}(t)$ 表示物体在时刻 $t$ 的三维空间位置向量。

* **导弹位置**:

  $$
  \vec{P}_{missile}(t) = \vec{P}_{missile\_start} + \vec{v}_{missile} \cdot t
  $$

  其中，$\vec{v}_{missile} = 300 \cdot \frac{\vec{P}_{fake\_target} - \vec{P}_{missile\_start}}{||\vec{P}_{fake\_target} - \vec{P}_{missile\_start}||}$
* **无人机位置**:

  $$
  \vec{P}_{uav}(t) = \vec{P}_{uav\_start} + \vec{v}_{uav} \cdot t
  $$

  其中，$\vec{v}_{uav} = (-120, 0, 0)$
* **烟幕弹起爆点位置**: 这是一个固定点，计算一次即可。

  1. 投放点位置: $\vec{P}_{drop} = \vec{P}_{uav}(t_{drop})$
  2. 起爆点位置（应用抛体运动公式）:
     $$
     \vec{P}_{detonate} = \vec{P}_{drop} + \vec{v}_{uav} \cdot \Delta t_{delay} + \frac{1}{2} \vec{g} \cdot (\Delta t_{delay})^2
     $$

     其中, $\vec{g} = (0, 0, -9.8)$
* **烟幕云心位置** (仅当 $t \ge t_{detonate}$ 时有效):

  $$
  \vec{P}_{cloud}(t) = \vec{P}_{detonate} + \vec{v}_{cloud} \cdot (t - t_{detonate})
  $$

  其中, $\vec{v}_{cloud} = (0, 0, -3)$

**Step 3: 建立遮蔽判定模型的核心公式**

定义遮蔽状态函数 $V(t)$：

$$
V(t) =
\begin{cases}
1, & \text{if } (t_{detonate} \le t < t_{expire}) \text{ and } (\text{IsIntersect}(\vec{P}_{missile}(t), \vec{P}_{target}, \vec{P}_{cloud}(t), R_{smoke})) \\
0, & \text{otherwise}
\end{cases}
$$

* 其中，$\vec{P}_{target} = (0, 200, 5)$ 是真目标关键点。
* $R_{smoke} = 10$ 是烟幕云半径。
* $\text{IsIntersect}(...)$ 是一个布尔函数，它判断连接 $\vec{P}_{missile}(t)$ 和 $\vec{P}_{target}$ 的线段是否与以 $\vec{P}_{cloud}(t)$ 为球心、$R_{smoke}$ 为半径的球体相交。其内部的计算基于**点到直线距离公式**和**一元二次方程求根**，这正是我们 `check_veiling` 函数所做的事情。

**Step 4: 实施数值积分**

1. 选择一个足够小的时间步长，例如 $\Delta t = 0.01$ s。
2. 设定一个足够长的仿真结束时间 `t_end`（例如70秒，确保导弹早已飞过）。
3. 初始化总时长 $T_{total} = 0$。
4. 编写一个循环，让时间 $t$ 从 0 增加到 `t_end`，每次增加 $\Delta t$。
5. 在循环的每一步：
   * 计算当前时刻的 $V(t)$ 值。
   * 如果 $V(t)=1$，则执行 $T_{total} = T_{total} + \Delta t$。
6. 循环结束后，得到的 $T_{total}$ 就是问题一的答案。

这个思路和公式体系，就是我们接下来要在 `solver_q1.py` 的主程序中用代码实现的完整逻辑。
