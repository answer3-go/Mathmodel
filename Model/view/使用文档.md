好的，完全没问题！我来为你写一份清晰、详细的**《V2.0 可视化仿真工具使用说明书》**。

把这个工具想象成一个“虚拟沙盘”，你只需要告诉沙盘“谁在场？”和“它们打算怎么做？”，沙盘就能自动推演出整个过程，并把结果画给你看。

---

### **核心理念：三步走**

使用这个工具，你永远只需要做三件事：

1.  **【输入】在 `main.py` 中定义“想定”**：告诉程序有哪些导弹、哪些无人机，以及它们的行动计划。
2.  **【处理】运行 `run_full_simulation` 函数**：启动物理引擎，计算出所有物体的完整轨迹。
3.  **【输出】调用“可视化函数”**：选择用“静态图”还是“动画”来展示计算结果。

现在，我们来详细拆解每一步。

---

### **第一步：【输入】如何定义一个“想定”**

你的所有“输入”工作，都**只在 `main.py` 文件中进行**。你需要修改两个核心的Python字典（Dictionary）变量。

#### **1. 定义战场上的“敌人”：`MISSILE_DEFINITIONS`**

这个字典定义了所有可能出现的导弹。每一枚导弹都是字典里的一个条目。

**格式：**
```python
# main.py

MISSILE_DEFINITIONS = {
    '导弹名字1': {'start': 初始位置, 'speed': 速度, 'target': 目标位置},
    '导弹名字2': {'start': 初始位置, 'speed': 速度, 'target': 目标位置},
    # ...可以一直加下去
}
```

**示例（题目给出的3枚导弹）：**
```python
# main.py

import numpy as np
P_FAKE_TARGET = np.array([0, 0, 0]) # 假目标位置

MISSILE_DEFINITIONS = {
    # 'M1' 是名字, 也是后续图例中的标签
    'M1': {
        'start': np.array([20000, 0, 2000]), # 必须是 np.array 格式的三维坐标
        'speed': 300.0,                     # 速度大小 (一个数字)
        'target': P_FAKE_TARGET             # 飞向的目标点 (一个 np.array)
    },
    'M2': {
        'start': np.array([19000, 600, 2100]),
        'speed': 300.0,
        'target': P_FAKE_TARGET
    },
    'M3': {
        'start': np.array([18000, -600, 1900]),
        'speed': 300.0,
        'target': P_FAKE_TARGET
    },
}
```

#### **2. 定义我方的“行动计划”：`uav_strategy`**

这个字典定义了所有我方无人机的行动计划。每一架无人机都是一个条目。

**格式：**
```python
# main.py

uav_strategy_xxx = {
    '无人机名字1': {
        'initial_pos': 初始位置,
        'velocity': 速度向量,
        'drop_times': [投放时间1, 投放时间2, ...], # 一个列表
        'detonation_delays': [引信延迟1, 引信延迟2, ...] # 一个列表
    },
    '无人机名字2': { ... },
}
```

**示例（问题1的策略）：**
```python
# main.py

uav_strategy_q1 = {
    # 'FY1' 是无人机的名字
    'FY1': {
        'initial_pos': np.array([17800, 0, 1800]),  # 初始三维坐标
        'velocity': np.array([-120.0, 0, 0]),     # 速度向量 (不是速度大小!)
        'drop_times': [1.5],                       # 投放时间列表，只有一枚弹
        'detonation_delays': [3.6]                 # 对应的引信延迟列表
    }
}
```
**关键点：**
*   `drop_times` 和 `detonation_delays` 是**列表（List）**，即使只有一枚弹也要用 `[]` 括起来。
*   如果你要模拟一架飞机投3枚弹（比如问题3），就写成：
    `'drop_times': [1.5, 3.0, 5.5]`
    `'detonation_delays': [3.6, 3.6, 3.6]`
    这两个列表的长度必须相等！

---

### **第二步：【处理】如何运行仿真**

定义好“想定”后，你需要告诉主程序，具体要用**哪些导弹**和**哪个策略**来进行本次仿真。

**做法：**
1.  从 `MISSILE_DEFINITIONS` 中挑出你这次想用的导弹，组成一个新的小字典。
2.  把你定义好的 `uav_strategy_xxx` 准备好。
3.  把这两个东西传给 `run_full_simulation` 函数。

**示例（运行问题1的想定）：**
```python
# main.py

# 1. 从所有导弹中，只挑出 M1
q1_missiles = {'M1': MISSILE_DEFINITIONS['M1']}

# 2. 选择问题1的无人机策略
# (uav_strategy_q1 已经在上面定义好了)

# 3. 把它们传给仿真函数，得到包含所有轨迹数据的 "结果大礼包"
simulation_results = run_full_simulation(q1_missiles, uav_strategy_q1)
```

这个 `simulation_results` 就是包含了所有计算结果的数据包，可以直接交给第三步去“画画”。

---

### **第三步：【输出】如何选择可视化方式**

你现在有两种“画画”的方式，可以任选一种，也可以两种都用。

#### **输出方式一：生成用于论文的“静态图”**

这会生成一张高质量的3D轨迹图，非常适合截图后插入你的Word或LaTeX论文中。

**调用方法：**
`plot_scenario_static_v2(仿真结果, output_filename="你的文件名.png")`

**示例：**
```python
# main.py

# 生成一张静态图，并把它保存为 "result1_visualization.png"
plot_scenario_static_v2(simulation_results, output_filename="result1_visualization.png")
```
程序会弹出一个窗口显示图片，同时在你的代码文件夹下生成一个PNG图片文件。你也可以保存成`.pdf`或`.jpg`格式。

#### **输出方式二：播放用于分析的“动画”**

这会弹出一个窗口，像播放电影一样，动态地展示整个对抗过程。这对于你理解策略的优劣、调试算法非常有帮助。

**调用方法：**
`animate_scenario(仿真结果, output_filename="你的视频名.mp4")`

**示例：**
```python
# main.py

# 播放动画。如果你想把它保存下来，可以提供一个文件名
# 注意：保存视频需要你的电脑安装了 ffmpeg 软件
animate_scenario(simulation_results, output_filename="result1_animation.mp4")
```
如果电脑没有`ffmpeg`，动画依然可以正常播放，只是不能保存成视频文件。

---

### **快速上手：一个完整的例子**

假设你要为**问题4**（3架无人机，各投1枚弹，对抗M1）创建一个可视化。

1.  **【输入】定义问题4的策略：**
    ```python
    # main.py
    uav_strategy_q4 = {
        'FY1': { # 假设这是你算法算出来的FY1的最优策略
            'initial_pos': np.array([17800, 0, 1800]),
            'velocity': np.array([-100.0, 20.0, 0]),
            'drop_times': [5.2],
            'detonation_delays': [4.1]
        },
        'FY2': { # FY2的策略
            'initial_pos': np.array([12000, 1400, 1400]),
            'velocity': np.array([-80.0, -30.0, 0]),
            'drop_times': [6.8],
            'detonation_delays': [3.5]
        },
        'FY3': { # FY3的策略
            'initial_pos': np.array([6000, -3000, 700]),
            'velocity': np.array([-70.0, 50.0, 0]),
            'drop_times': [4.5],
            'detonation_delays': [3.8]
        }
    }
    ```

2.  **【处理】运行仿真：**
    ```python
    # main.py
    q4_missiles = {'M1': MISSILE_DEFINITIONS['M1']}
    q4_results = run_full_simulation(q4_missiles, uav_strategy_q4)
    ```

3.  **【输出】生成结果：**
    ```python
    # main.py
    # 为问题4的结果生成一张静态图，并保存
    plot_scenario_static_v2(q4_results, output_filename="result2_visualization.png")

    # 同时，播放动画来检查策略是否合理
    animate_scenario(q4_results)
    ```

就是这么简单！你现在已经完全掌握了这个强大的可视化工具。祝你们比赛顺利！